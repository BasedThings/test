generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============== ENUMS ==============

enum Platform {
  POLYMARKET
  KALSHI
  PREDICTIT
}

enum MarketStatus {
  ACTIVE
  CLOSED
  RESOLVED
  CANCELLED
}

enum MatchStatus {
  PENDING_REVIEW
  CONFIRMED
  REJECTED
  STALE
}

enum ArbitrageStatus {
  ACTIVE
  EXPIRED
  EXECUTED
  MISSED
}

// ============== MARKETS ==============

model Market {
  id          String       @id @default(cuid())
  platform    Platform
  externalId  String
  slug        String?
  question    String
  description String?
  category    String?

  // Outcomes (stored as JSON for flexibility)
  outcomes Json @default("[\"Yes\", \"No\"]")

  // Pricing
  yesPrice Decimal  @db.Decimal(10, 6)
  noPrice  Decimal  @db.Decimal(10, 6)
  yesBid   Decimal? @db.Decimal(10, 6)
  yesAsk   Decimal? @db.Decimal(10, 6)
  noBid    Decimal? @db.Decimal(10, 6)
  noAsk    Decimal? @db.Decimal(10, 6)
  midpoint Decimal? @db.Decimal(10, 6)
  spread   Decimal? @db.Decimal(10, 6)

  // Liquidity
  liquidity   Decimal? @db.Decimal(18, 2)
  volume24h   Decimal? @db.Decimal(18, 2)
  volumeTotal Decimal? @db.Decimal(18, 2)

  // Fees and limits
  feeRate      Decimal @db.Decimal(6, 4)
  minOrderSize Decimal @db.Decimal(10, 2) @default(1)
  tickSize     Decimal @db.Decimal(6, 4)  @default(0.01)

  // Order book depth (snapshot)
  orderBookDepth Json?

  // Timing
  startDate      DateTime?
  endDate        DateTime?
  resolutionDate DateTime?

  // Resolution
  resolutionSource String?
  resolutionRules  String?
  resolvedOutcome  String?

  // Status
  status MarketStatus @default(ACTIVE)

  // Metadata
  sourceUrl String?
  imageUrl  String?
  tags      String[]

  // Data quality
  lastFetchedAt  DateTime
  fetchLatencyMs Int?
  dataVersion    Int      @default(1)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  priceHistory    PriceSnapshot[]
  matchesAsSource MarketMatch[]   @relation("SourceMarket")
  matchesAsTarget MarketMatch[]   @relation("TargetMarket")

  // Indexes
  @@unique([platform, externalId])
  @@index([platform, status])
  @@index([category])
  @@index([status, yesPrice])
  @@index([lastFetchedAt])
}

// ============== PRICE HISTORY ==============

model PriceSnapshot {
  id       String @id @default(cuid())
  marketId String
  market   Market @relation(fields: [marketId], references: [id], onDelete: Cascade)

  yesPrice Decimal  @db.Decimal(10, 6)
  noPrice  Decimal  @db.Decimal(10, 6)
  yesBid   Decimal? @db.Decimal(10, 6)
  yesAsk   Decimal? @db.Decimal(10, 6)
  noBid    Decimal? @db.Decimal(10, 6)
  noAsk    Decimal? @db.Decimal(10, 6)
  spread   Decimal? @db.Decimal(10, 6)

  liquidity Decimal? @db.Decimal(18, 2)
  volume    Decimal? @db.Decimal(18, 2)

  fetchLatencyMs Int?

  timestamp DateTime @default(now())

  @@index([marketId, timestamp])
  @@index([timestamp])
}

// ============== MARKET MATCHES ==============

model MarketMatch {
  id String @id @default(cuid())

  // Markets being matched
  sourceMarketId String
  sourceMarket   Market @relation("SourceMarket", fields: [sourceMarketId], references: [id])
  targetMarketId String
  targetMarket   Market @relation("TargetMarket", fields: [targetMarketId], references: [id])

  // Match quality scores
  semanticScore   Decimal @db.Decimal(5, 4)
  resolutionScore Decimal @db.Decimal(5, 4)
  dateScore       Decimal @db.Decimal(5, 4)
  overallScore    Decimal @db.Decimal(5, 4)

  // Match explainability
  matchReason    String
  matchedTerms   String[]
  resolutionDiff String?

  // Status
  status      MatchStatus @default(PENDING_REVIEW)
  reviewedAt  DateTime?
  reviewedBy  String?
  reviewNotes String?

  // Denormalized for fast queries
  sourcePlatform Platform
  targetPlatform Platform

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  arbitrageOpps ArbitrageOpportunity[]

  @@unique([sourceMarketId, targetMarketId])
  @@index([status, overallScore])
  @@index([sourcePlatform, targetPlatform])
}

// ============== ARBITRAGE OPPORTUNITIES ==============

model ArbitrageOpportunity {
  id String @id @default(cuid())

  matchId String
  match   MarketMatch @relation(fields: [matchId], references: [id])

  // Strategy
  strategy Json

  // Spread calculation
  grossSpread      Decimal @db.Decimal(10, 6)
  netSpread        Decimal @db.Decimal(10, 6)
  spreadPercentage Decimal @db.Decimal(6, 4)

  // Fee breakdown
  sourceFee Decimal @db.Decimal(10, 6)
  targetFee Decimal @db.Decimal(10, 6)
  totalFees Decimal @db.Decimal(10, 6)

  // Prices at detection
  sourceYesPrice Decimal @db.Decimal(10, 6)
  sourceNoPrice  Decimal @db.Decimal(10, 6)
  targetYesPrice Decimal @db.Decimal(10, 6)
  targetNoPrice  Decimal @db.Decimal(10, 6)

  // Liquidity analysis
  maxProfitableSize Decimal @db.Decimal(18, 2)
  liquidityScore    Decimal @db.Decimal(5, 4)
  estimatedSlippage Decimal @db.Decimal(6, 4)

  // Confidence scoring
  confidenceScore   Decimal @db.Decimal(5, 4)
  freshnessScore    Decimal @db.Decimal(5, 4)
  consistencyScore  Decimal @db.Decimal(5, 4)
  confidenceFactors Json

  // Execution plan
  executionSteps      Json
  estimatedExecutionMs Int?

  // Status tracking
  status       ArbitrageStatus @default(ACTIVE)
  detectedAt   DateTime        @default(now())
  expiresAt    DateTime?
  closedAt     DateTime?
  closedReason String?

  // Data quality
  sourceDataAge Int
  targetDataAge Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, netSpread])
  @@index([status, confidenceScore])
  @@index([detectedAt])
  @@index([matchId, status])
}

// ============== USER PREFERENCES ==============

model FilterPreset {
  id          String  @id @default(cuid())
  name        String
  description String?

  // Filter criteria
  filters Json

  // Sorting
  sortBy    String @default("netSpread")
  sortOrder String @default("desc")

  // Display preferences
  columns String[]

  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Watchlist {
  id          String  @id @default(cuid())
  name        String
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items WatchlistItem[]
}

model WatchlistItem {
  id          String    @id @default(cuid())
  watchlistId String
  watchlist   Watchlist @relation(fields: [watchlistId], references: [id], onDelete: Cascade)

  marketId String?
  matchId  String?

  alertThreshold Decimal? @db.Decimal(6, 4)
  alertEnabled   Boolean  @default(false)

  notes String?

  createdAt DateTime @default(now())

  @@index([watchlistId])
}

// ============== AUDIT & LOGGING ==============

model AuditLog {
  id String @id @default(cuid())

  action     String
  entityType String
  entityId   String?

  details Json

  timestamp DateTime @default(now())

  @@index([entityType, entityId])
  @@index([timestamp])
  @@index([action])
}

model SystemMetric {
  id String @id @default(cuid())

  metric String
  value  Decimal @db.Decimal(18, 6)
  tags   Json?

  timestamp DateTime @default(now())

  @@index([metric, timestamp])
}
